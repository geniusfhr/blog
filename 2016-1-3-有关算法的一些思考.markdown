---
layout: post
title:  "有关算法的思考"
date:   2016-1-3 18:14:00 +0800
categories: algorithm data-structures sort idea
author: 浩然
---


## 关于算法的思考  




&nbsp;&nbsp;&nbsp;&nbsp;大一的下学期已经开始在看数据结构，可惜严奶奶的书写的可能太晦涩，对这门课程的兴趣减了不少。不过不管是从知乎，还是学长学姐，各位大牛的口中，都感受到数据结构和算法课程的重要性。当时读的时候，最大的疑惑就是为什么数据结构和算法要放在一起。数据结构部分关于顺序表，链表，树，图，以及算法部分的查找，排序，看起来相关性不是很大。可是几乎所有的书都讲它们放在一起讲解。当然还有c，c++，python 乃至js这些不同语言描述的算法书，语言的不同让我更加疑惑，甚至导致我当时在图书馆不知道到底要找什么书了。这学期的数据结构和算法设计，应该算是第一门专业课，之前的c/c++只能算作专业基础课吧。直至今日，学期已经快要结束，算法课也差不多完结了。有一些体会想写在这里，作为自己的算法课小结。  



&nbsp;&nbsp;&nbsp;&nbsp;数据结构和算法，我觉得前者是为后者作铺垫的。第一部分数据结构的学习，比如链表，二叉树，了解他们的构造，遍历，插入，删除等基本的操作，单纯地学习数据结构，数据不同的组织方式，形成不同的结构，是一个比较枯燥的过程，细节很多，有的地方甚至稍微需要一些记忆，在用语言
实现地时候才会上手比较快。到了算法这部分，就需要设计不同的结构来构造精妙的算法。比如堆排序，实际上是选择排序的一种优化。每次选择最大(小)的元素插入序列。那么对于这个选择的过程就有不同的实现方式。最简单的，遍历，记录最大值下标，一遍之后，就可以找出最大值。但是这种方式效率较低，第二遍再遍历找出第二大的元素的过程中，很多比较已经做过，这就明显降低了效率。于是计算机科学家使用堆这个结构，反复构造大顶堆，每次取其根元素，这样就设计出了堆排序的算法。堆结构的构造，需要对树的结构有相当深的理解，才能设计出如此精妙的算法吧。  

## 总结排序算法

&nbsp;&nbsp;&nbsp;&nbsp;排序算法分为四类，`选择，交换，插入，归并`，每种算法的思想都很独到。

### 选择排序类
&nbsp;&nbsp;&nbsp;&nbsp;我觉得最贴近人脑思考过程的算法应该是`选择排序`。举个例子， `3 5 1`这三个数从小到大排序，很自然的得出排序结果是`1 3 5`，再仔细地回忆一下过程，我们先将三个数都扫了一遍，发现了最小的1，肯定将1放在第一位，接着在35中发现了3更小，放在第二位，最后剩下最大的5放在最后。这样135的顺序就排出来了。数字越多，这种思维的过程会更加凸显。给你1000个数排序，那么自然地找出最小的放在最前，再在剩下的中找最小的放第二，直到所有的数都排完。这个时候计算机的优势就会显现出来了，一定是比人脑快的。这种算法的核心就在于每次找到最小的那个。下面是c的实现过程。

```java

//从小到大   选择排序 selection_sort a待排数组  n 元素个数
void selection_sort(int* a,int n ){             // from 1 to n
    for(int i = 1; i <= n; i++ ){               //当前位置
        int min = i;
        for(int j = i ; j <= n ;j++){
            if(compare(a[min],a[j])){           //如果当前j比min小 记录下标
                min = j;
            }
        }
        swap(a[min],a[i]);                      //交换当前和以后最小值  select出了最小放在i的位置
    }
}

```

&nbsp;&nbsp;&nbsp;&nbsp;`堆排序`是对简单选择排序的改进，改进之处就在于最大（小）元素的选择过程上。每次取堆顶元素（最大/小），直至全部取完。  


```java

void heap_sort(int* a,int n ){
    for(int i = n/2; i > 0; i--){
        heapAdjust(a,i,n);          //从n的调整到1 使整个成为一个大顶堆
    }

    for(int i = n; i > 1; i--){
        swap(a,i,1);                //将最大和堆顶最大元素进行交换  最后元素成为最大
        heapAdjust(a,1,i-1);          //重新调整第一个元素 保持最大堆
    }
}
//对a进行堆调整 s为当前调整元素 m为末尾元素下标
void heapAdjust(int* a,int s,int m ){
    int t ,j;
    t = a[s];
    for(j = 2*s; j <= m; j  = j*2){
        if(j < m && a[j] < a[j+1]){
            j++;                //找到s孩子结点中最大的那个 记录为j
        }
        if(t > a[j]){           //如果双亲结点比孩子结点最大的还大  不需要交换
            break;
        }
        a[s] = a[j];            //j翻上去
        s = j;                  //开始将j作为s待调整调整 讨论子节点
    }//退出循环 找到插入位置s
    a[s] = t;                   //将待调整元素插入位置
}

```


### 插入排序类

&nbsp;&nbsp;&nbsp;&nbsp;`插入排序`的过程一直是在做插入动作的。对于第二个元素起，找到每个元素在之前已经有序数列中的位置，再插进去，直到最后一个元素完成插入，从而完成整个数组的排序。

```java

void my_insertion_sort(int* a,int n ){       //直接插入排序 从小到大
    for(int i = 2; i <= n; i++){
        a[0] = a[i];                     //哨兵 记录插入元素
        if(a[i] < a[i-1]){              //与有序端最后比较  需要插入
             int j;
             for( j = 1; j <= i-1; j++){
                if(a[0] <= a[j])          //找到插入的位置 j 跳出循环
                    break;
            }
            for(int k = i-1; k >= j; k--){      // j 到 i-1 后移一位
                a[k+1] = a[k];
            }
            a[j] = a[0];                       //插入该元素
        }
    }
}
```

###  交换排序类
&nbsp;&nbsp;&nbsp;&nbsp;算法的核心是通过不断地交换元素的位置来实现整个序列的有序。比如在c语言中最先接触到的`冒泡排序`。abc三个元素从头开始两两比较，如果a>b,那么交换ab的位置，接着比较二三两个元素，如果第二个大，那么再交换位置，这样经过一轮循环，第三个位置上就成了最大的元素。就像它的名字一样，最大的气泡冒到了最上面。第二轮循环，在一二中找到最大的，放在二的位置，最后剩下的就是最小的元素。

```java

//冒泡排序
void bubble_sort(int* array,int n){
    for(int i = n-1; i >= 1; i--){
        for(int j = 1;j <= i;j++){
            if(compare(array[j],array[j+1])){
                exchange(array[j],array[j+1]);
            }
        }
    }
}

```

&nbsp;&nbsp;&nbsp;&nbsp;对冒泡排序的改进是`快速排序`。这也是一种交换类的排序算法。从它的名字就能看出，这种算法应该是效率最高，时间最快的。主要思想是每次确定一个枢轴，在其他元素中找到比这个轴大的放在右边，比它小的放在左边，这个过程可以通过交换完成。这样达到两部分相对有序。再对左右两部分分别递归地进行这个过程，这样细分到一次只有一个元素的时候就完成了整个数组的排序工作。是不是很巧妙呢。

```java

//对a从 low - high 进行快速排序
void quick_sort(int* a ,int low,int high){      //快速排序
    int pivot;                  //枢轴
    if(low <  high) {
        pivot = partition(a,low,high);      //两边分 并返回枢轴
        quick_sort(low,pivot);              //枢轴左边进行递归快排
        quick_sort(pivot+1,high);           //右边递归快排
    }
}

//对a进行两边分  选取枢轴 比其小放左边 反之放右边
int partition(int* a,int low,int high) {
    int pivotKey = a[1];
    while(low < high ){
        while(low < high && a[low] <= pivotKey){        //注意等号
            low++
        }
        swap(a,low,high);                   //交换当前

        while(low < high && a[high] >= pivotKey){
            high--;
        }
        swap(a,low,high);
    }

    return low;                 //返回枢轴
}

```

### 归并排序类

&nbsp;&nbsp;&nbsp;&nbsp;个人觉得`归并排序`是最不容易理解的一种，因为想要自然地理解递归并且设计递归需要相当长的一段时间。归并的精髓就在递归。对整个数组排序的过程，是将左右两部分排好序之后，再将这两部分合并的过程。左右两部分的排序，同样也是按照这个逻辑，可以想象，直到一组中只有两个数进行比较的时候，全部的排序工作就差不多完成了，只需要将所有的组两两归并，而这个过程是在递归的后半部分自动完成的。返回当前函数的调用的下一句，就是归并函数的调用。

```java

void MSort(int* a,int* b,int m ,int n){

    int c[100];
    if(m == n){             //直到分成两个元素
        b[m] = a[m];
    } else {
    int s = (m + n)/2;
    MSort(a,c,m,s);         //递归 将a中m到s归并到c中
    MSort(a,c,s+1,n);       //递归 将a中s+1到n归并到c中
    Merge(c,b,m,s,n);       //将c中已经排好序的两部分 进行归并
    }
}


//归并
void Merge(int* a,int* b ,int m,int s,int n){
    int i,j,k = m;
    for(i = m,j = s+1; i <= s && j <= n ; k++ ){
        if(a[i] < a[j]){        //如果i < j
            b[k] = a[i++];      //较小的i放入k i后移
        }else {
            b[k] = a[j++];         //反之 j放进k  j后移
        }
    }

    while(i <= s){
        b[k++] = a[i++];
    }

    while(j <= n){
        b[k++] = a[j++];
    }
}

```
